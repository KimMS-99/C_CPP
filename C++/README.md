# IntelAISW_cpp, 명품 C++ 프로그래밍
***
## 목차
[1. C++시작](./Ch1#1장-C시작)<br>
[2. C++프로그래밍의 기본](./Ch2/#2장-C프로그래밍의-기본)<br>
[3. 클래스와 객체](./Ch3#3장-클래스와-객체)<br>
[4. 객체 포인터와 객체 배열, 객체의 동적 생성](./Ch4/#4장-객체-포인터와-객체-배열-객체의-동적-생성)<br>
[5. 함수와 참조, 복사 생성자](./Ch5#5장-함수와-참조-복사-생성자)<br>
[6. 함수 중복과 static 멤버](./Ch6/#6장-함수-중복과-static-멤버)<br>
[7. 프렌드와 연산자 중복](./Ch7#7장-프렌드와-연산자-중복)<br>
[8. 상속](./Ch8/#8장-상속)<br>
[9. 가상 함수와 추상 클래스](./Ch9#9장-가상-함수와-추상-클래스)<br>
[10. 10장 템플릿과 표준 템플릿 라이브러리(STL)](./Ch10/#10장-템플릿과-표준-템플릿-라이브러리STL)<br>
[11. C++ 입출력 시스템](./Ch11#11장-C-입출력-시스템)<br>
[12. C++ 파일 입출력](./Ch12/#12장-C-파일-입출력)<br>
[13. 예외 처리와 C 언어와의 링크 지정](./Ch13#13장-예외-처리와-C-언어와의-링크-지정)<br>

***

# Makefile 설명

## 구조
+ 현재 디렉토리의 하위 디렉토리 중 Makefile이 있는 곳만 자동으로 찾아서
+ make 실행 (빌드)
+ make clean 시에도 해당 디렉토리들만 대상으로 make clean 실행
+ 최상위 Makefile에서 한 번에 전체 프로젝트 빌드/클린 가능

## 라인별 설명
### 하위디렉토리 찾기
+ SUBDIRS: 하위 디렉토리 중 Makefile이 존재하는 디렉토리 목록을 자동으로 수집
+ find: 리눅스 명령어. 현재 디렉토리에서 검색 수행
+ -mindepth 2: 현재 디렉토리는 제외하고, 최소 2단계 하위만 포함
    -mindepth 2를 사용하면 현재 디렉토리 바로 아래(./something/Makefile)는 제외됨 	→ 예: ./src/Makefile은 제외, ./src/lib/Makefile은 포함됨
+ -name Makefile: 파일 이름이 정확히 "Makefile"인 파일만 탐색
+ -exec dirname {} \;: Makefile의 디렉토리 경로만 추출
+ 결과: SUBDIRS는 예를 들어 ./src, ./lib/utils 등으로 채워짐
+ 하위 디렉토리 내에 Makefile이 많아질수록 자동 확장됨
+ $(shell ...)은 make 실행 시점에 한 번만 수행됨 (동적이지만 고정된 값으로 사용됨)

### 가짜 타겟 선언 (실제 파일과 무관한 명령)
+ all, clean이라는 이름의 파일이 실제로 존재하더라도 무시하고 명령어로 인식시킴
+ make는 기본적으로 파일 기반이기 때문에, 이 선언이 없으면 파일이름과 충돌날 수 있음
+ make all 또는 make clean 실행 시, 실제 all이나 clean이라는 파일이 있더라도 무시하고 명령어로 실행
+ 습관적으로 run, test 같은 사용자 정의 타겟에도 .PHONY를 쓰는 게 안전함

### 기본 빌드 타겟
+ make 또는 make all 입력 시 실행됨
+ @echo ...: 현재 진행 중인 작업 메시지 출력
+ for dir in $(SUBDIRS); do ... done: 찾은 하위 디렉토리들 반복
+ $(MAKE) -C $$dir: 해당 디렉토리로 이동해서 make 실행
<br>• -C $$dir: cd $$dir && make와 같은 효과
<br>• $$dir: for 루프 안에서 디렉토리 이름
<br>• $(MAKE)는 make의 특별한 변수로, 내부적으로 make를 재귀적으로 호출할 때 정확하게 환경 변수를 유지해줌 (예: MAKEFLAGS, 병렬 빌드 등)
<br>• -C $$dir: 디렉토리를 바꿔서 make 실행. cd 명령과는 달리 명령 단위로 수행되기 때문에 훨씬 안전함
<br>• @로 시작하는 라인은 출력 억제 (명령어 자체는 콘솔에 안 보임, 결과만 출력)

### 클린(하위 빌드 결과 삭제)
+ make clean 입력 시 실행됨
+ 하위 디렉토리 반복
+ 해당 디렉토리에 Makefile이 실제 존재하는지 확인 후
+ make clean 실행
+ echo로 각 디렉토리에서 클린 중이라는 메시지 출력
+ -f $$dir/Makefile은 혹시 중간에 Makefile이 삭제된 디렉토리가 있어도 오류 없이 넘어가게 하기 위해 + 체크하는 안전 장치
여기서도 $(MAKE) -C로 context 유지하며 clean 실행


### 특정 디렉토리의 run 타겟 실행
+ $@는 현재 타겟 (run_Ch8_P379 같은 문자열)
+ $(subst run_,,$@) → Ch8_P379
+ $(subst _,/,$(...)) → Ch8/P379
+ $(MAKE) -C Ch8/P379 run 실행됨
+ 중첩된 디렉토리 경로를 _로 연결해서 간단하게 쓸 수 있는 유용한 매커니즘



## 사용법 
+ make : 현재 폴더 기준으로 하위에 있는 모든 Makefile이 있는 디렉토리에서 빌드 실행
+ make all : 위와 동일, 기본 타겟
+ make clean : 하위 모든 Makefile 있는 디렉토리에서 make clean 실행
+ make run_Ch8_Test : Ch8/Test 폴더 안에 Makefile 실행

## 전체 흐름 요약
최상위 디렉토리에 이 Makefile만 있어도, 하위 폴더에 따로 Makefile이 있는 경우 자동으로 인식
하위 폴더를 따로 지정할 필요 없이 자동 탐색
깔끔하게 전체 빌드, 전체 클린 가능

